#summary Awesomeguy is a computer game for the Android 2.1/2.2 phone.
#sidebar TableOfContents

= Introduction =

Awesomeguy is a computer game originally developed for another hand held game system that I am attempting to port to the Android platform. 
<wiki:toc max_depth="5" />
= Details =

The format of the Awesomeguy game is that of a simple platform game, in some ways like the original “Donkey Kong” or “Super Mario Brothers”. The Nintendo DS version has two screens of 192x256 pixels each. During gameplay one of the screens was generally used as a splash screen. The game also makes use of four directional keys and two special keys -- one of which is the 'jump' key. [Awesomeguy#Awesomeguy top]

The android phone that the game was developed for had no "D-pad". For the android version, two separate View objects were required during regular game play. One View was for display of the game screen, the equivalent of the main screen from the Nintendo game, and the other View was the emulated "D-pad". The "D-pad" was emulated using TouchButtons on the touch screen and also an alternative where movement instructions were taken from the trackball. The DS version of the game uses several large int arrays for keeping track of the appearance of each level in the game. In order to port the levels to the android version, the same sort of array was used in the android code. In this way the android version can use the exact same level definition info. The android version also uses an ArrayList to keep track of sprite data, though sprites are not hardware supported in java. One ArrayList is used for all types of sprites. The DS version makes use of a set of four tiles that are used to paint the levels from the predefined level array on the game screen. The same tile set was used in the android version, but software was used to emulate the DS's hardware tiling system. For these reasons the android version of the game is slower to play than the homebrew DS version.

===Tilesheets===

Tilesheets are very important to the Awesomeguy game. Tilesheets do not exist natively in the Java language, so they must be simulated for the Android phone using code. The basic concept behind tilesheets is complex. A tilesheet is made up of many 8x8 squares. Each square is referred to as a tile. The tilesheet itself can contain many hundreds of tiles. The game uses the tilesheet to draw the background that the user sees as they play the game. Rather than paint a different background for each level, a map is used. The map is a matrix, and each number in this 2D matrix represents an 8x8 tile from the tilesheet. This cuts down on memory usage. Rather than save to a file the entire drawing of the background of some level, the programmer saves the matrix, or map, which is smaller but represents the same picture. The programmer then creates the game background by building one of these maps, which is much smaller than the complete drawing of the background might be. The game system on which the Awesomeguy game was developed used a tilesheet/map system similar to the one described, only it was implemented on the hardware level. In order to make Awesomeguy look exactly like the original, the tilesheets from the original game were copied and imported to the Android app, and the tiling system was emulated in software.

Awesomeguy uses two map arrays for each level, and it uses four tile sheets. The tilesheets are shared by all levels of the game, and they are nearly identical. 

The first map array holds a definition for the background of the level that is much the same as the one discussed above. This is a map of the visible background of the level that's being played. The second map array is identical in size to the first one. It holds information about what each picture in the other map means to the program and the character. Where the first map shows a solid wall, the second map holds a number that tells the program that the character may not pass through it. Walls in the first array can be many colors and patterns as chosen from the tilesheet, but in the second array, just one number corresponds to all wall objects. The first array is visible while the second array is never seen. The first array is referred to as the 'level' or 'tile' array, and the second array is referred to as the 'objects' array. Remember, the two arrays are always the same size.

The way the four tilesheets work is relatively simple. They are identical in size and content except for the images imbedded in the tilesheet of the rings. The rings are prizes in the game and when you get one you get points. There are four tilesheets so that the rings can be animated and made to look like they are turning. The difference in the ring images is the only difference in the four tilesheets. To make the rings look like they are moving the tilesheets are swapped during game play. This swapping happens in the  'setTilesheet(int i)' function. See: [Awesomeguy#setTilesheet() setTilesheet()] for a code listing. [Awesomeguy#Awesomeguy top]

===Tilemaps===

Another important component in the Awesomeguy game is the set of map arrays collectively known as tilemaps. These large 2 dimensional arrays contain the data that is used to decide what gets painted on the background screen and where it gets painted. The tilesheets are divided up into 8x8 squares. Every square gets a number, and those numbers populate the tilemaps. One of the tilemap's indexes represents the x axis, and another represents the y axis. The matrix then can cover a 2D plane with values. If the programmer wants to put a ladder in the upper left hand corner, he or she takes a 8x8 square representing a ladder from the tilesheet and places it in the tilemap at the location with the 0,0 indexes. The screen is defined this way, so that the upper-right has high x values and low y values, the lower-left has high y values and low x values, and the lower-right has both high x and y values. This reflects the numbering of pixels on a computer screen, but in this model each pixel is a complete tile from the tilesheet.

Tilesheets are not numbered with two indexes. Tilesheet 8x8 squares are numbered with a single index. For this reason it's difficult to change the size of a tilesheet once it has been established. A tilesheet containing 8x8 squares in a pattern of 3 tiles by 5 tiles would have tiles numbered 0 to 14. A tilemap element contains one of these numbers. One number typically represents 'nothing' or 'no contents', while another number might represent a solid object (like a wall) and another number might symbolize the tile that contains the image for a ladder.

For Awesomeguy there are two identical tilemaps. One holds all the information mentioned above. It holds designations for where to place tiles that show images of walls and ladders and floors. The second tilemap holds extra information that the game needs. This info includes the starting location of the main character, the starting location of each monster, further information about the location of walls and floors, the location of floating platforms, and the location of all the rings and prizes on the level. It holds the code for the checkpoint character and the level goal character and also the code for a special tile that causes instant death when it is touched. The two tilemaps are called the 'level' tilemap and the 'object' tilemap. They are exactly the same size, and an element at a certain x/y location on one map refers to the same spot on the screen as that x/y location on the other map. The two maps can be laid on top of each other.

The reason for two maps is so that one map, the 'level' map, can be responsible for drawing the image of the background, while the other map, the 'object' map, is responsible for telling the program how to treat that particular set of elements. Only some of the 'object' map elements result in an actual object being drawn on the screen. Rings, for example, are drawn on the screen until the player gets them. Similarly, not all 'level' objects are solid objects. Some, like some of the pillars, are only for outward appearances.

===Sprites===

Aside from the tilesheets and tilemaps described above, the game uses several sprite images. For these images small 'png' files were used. There are four images of the main character and two images of the monster for each direction. That means four monster images in total, two left and two right. The multiple images are used to animate the main character and the monsters. Each of the 'png' images has an alpha channel (a transparent area) and is indexed to a 256 color palette. The size of the images is unimportant on the android phone, but for the Nintendo DS it was dictated by the hardware. For this reason the monster sprite uses only the top half of the png image, which is 16 pixels by 16 pixels. The main character is also 16 x 16, but it uses the space more evenly.

===Software Tools===

Several pieces of software were used when making Awesomeguy. Awesomeguy was programmed on a Linux computer. The graphic images in the game were all edited on Gimp, the Gnome Image Manipulation Program. The source code for Awesomeguy was edited using the Eclipse IDE for java. The C library used for the Awesomeguy Java Native Interface (JNI) was edited using Gedit, another Gnome program. The tilemaps, the large arrays that define the appearance of each level, were edited first using a Windows program called 'Mappy', and then further edited using Gedit and the command line tool 'sed'. The Wine (Wine Is Not An Emulator) program loader was employed to allow Mappy to work on a Linux platform. Instructions for using Mappy to create level definitions will accompany this document.

----

=!AndroidManifest xml=

The AndroidManifest.xml file has entries for each of the game's activities. In the xml entry for the SplashScreen activity, the values for 'clearTaskOnLaunch' are set to 'true', and the values for 'launchMode' are set to 'singleTask'. This arrangement is shown in the following snippet. The 'clearTaskOnLaunch' option is what allows the game to always restart with the Splash Screen regardless of what state it was in when it was stopped. This option was used in each of the activities in the xml file.

{{{
<activity android:name=".SplashScreen"
android:label="@string/app_name"
android:clearTaskOnLaunch="true"
android:launchMode="singleTask">
}}}

For each of the activities of the application I put 'clearTaskOnLaunch' as one of the xml parameters (as noted above).

{{{
<activity android:name=".Menu"
android:clearTaskOnLaunch="true">
}}}


=!SplashScreen java=

When the game starts the user is presented with a splash screen that dismisses itself when the user presses the screen or when a certain amount of time has passed. The splash screen activity performs certain tasks when it displays. One thing that it does is initializing the database that holds the player scores. It also creates a new blank player record for storing high scores and user preferences. (It doesn't give this new record a user name -- that's saved for if the user decides to do so). Then it sets the default starting level to '1'. This way if the game is started without the user expressing their preference, the starting room number will be '1'. [Awesomeguy#Awesomeguy top]

=Menu java=

The next thing that the user sees is a menu. This menu allows the user to view a 'help' or 'credits' file, enter 'options' that effect game play and the way scores are saved, go to a 'players' selection screen, or simply 'play game'.  The last option forwards the user to the actual game. Each of the options on the menu launches another android Activity. The AndroidManifest.xml file is set up to ensure that the game starts over at the splash screen whenever it exits normally.  [Awesomeguy#Awesomeguy top]



=!GameStart java=

Game play is handled by the GameStart.java activity. The first thing that happens in the activity is that the screen is drawn. Layout of the screen is handled using code and not an xml file. The screen is roughly divided into two sections. There is a top panel for the actual display of the game while the user is playing, and there is the area below the top screen which is where buttons appear for controlling the movement of the game's main character. The top screen is an instantiation of a Panel.java class, which is a SurfaceView. Layout elements are all assembled in the 'onCreate()' method of the GameStart activity. One of the first things that's done when assembling the Views on the screen is to measure the size of the display. This is done with code like this:

{{{
Display display = ((WindowManager) getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();    	
int mDimension = display.getWidth();
}}}
This width dimension is used to size the game screen and the touch buttons. A separate function is used to construct the touch button part of the screen. This function is called 'getGamePad(int width)' and it returns an entire TableLayout already filled with all the necessary buttons. Two types of buttons are used, one called a BlankButton and one called a TouchButton. Both kinds of buttons are inner classes in the GameStart.java file, and they both extend the android 'Button' type. The TouchButton also implements the 'View.OnTouchListener' interface, which allows the program to respond to user input.  [Awesomeguy#Awesomeguy top]

===onPause()===

The 'onPause()' method of the GameStart.java activity waits for the game loop to exit. The 'onPause()' method sends a message to the InnerGameLoop thread to exit all loops, and then the 'join()' command waits for the thread to finish. It also saves the high scores for the current player to the high score database.  [Awesomeguy#Awesomeguy top]

===onResume()===

The 'onResume()' method of the GameStart.java activity begins by retrieving from the SharedPreferences the user record for the current user. This is so that if the user made changes to their game play experience using the 'Players' menu or the 'Options' menu, then those changes could be referenced in the 'GameStart' activity. The method 'onResume()' also finishes the job of building the game controls and adding them to the View that the game is displayed in. It also starts a separate thread called the InnerGameLoop. This Thread is a inner java class which is found in the body of the GameStart class. It is used to help process user input and direct the SurfaceView to refresh when it is necessary. The 'onResume()' method also instantiates a new InitBackground.java class. This class loads the definition information for each new level. Info about the shape of each level and the placement of various objects in the game (like rings and lives) are loaded in this object. [Awesomeguy#Awesomeguy top]

===!TouchButton===

Next in the GameStart.java class is the inner class that describes the object called TouchButton. The TouchButton extends the regular android Button class and is used in the 'getGamePad( int x )' method when the game's movement and jump buttons are created. Five times this variant of the android Button class is used. The TouchButton class implements 'View.onTouchListener', which allows the buttons to detect pressure from the touch screen. The touch buttons use the MotionEvent.ACTION_DOWN and MotionEvent.ACTION_UP constants in the 'onTouch()' method to detect key presses. Then the value for the key (up, down, left, right, etc.) is passed to the functions that process this key input, functions that are part of the MovementValues and the Panel classes respectively.

There is one particularly useful constructor in the TouchButton class. There are seven parameters to the constructor. They set the button's context, background resource, width, and height. They also set the values in the TouchButton that show which 'direction' the button represents (a constant for up, down, left, right, and B) and an optional string that can be used for identification purposes. The TouchButton is also set up to receive input from the trackball. All TouchButton buttons are listening for trackball input. The code to include trackball input is incorporated in the 'View.OnKeyListener()' object, which is an anonymous class in the TouchButton constructor code.  [Awesomeguy#Awesomeguy top]

===!BlankButton===

Another inner class in the GameStart.java file is the 'BlankButton'. This button is the same height and width of the TouchButton, but has no event listeners. It's used to fill in the spaces between the more important TouchButtons in 'getGamePad(int num)' [Awesomeguy#Awesomeguy top]

===mHandler===

Next in the GameStart.java class is the inner class defining the Handler 'mHandler'. This class sets up a queue for processing events in the program. It's especially useful for updating the Panels that contain the graphical information for the game. These panels can only be updated from the thread that started them, so the InnerGameLoop thread, described below, can only request that the screen be redrawn by using this queue device as it exists in a separate thread. Message objects are sent by different classes in the application to the Handler, which puts each message on the queue -- usually in the order they were recieved. Types of messages are defined as static final ints at the beginning of the GameStart class. It also has a use when we are trying to launch an AlertDialog from inside the InnerGameLoop. This too can only be done from the original thread of the GameStart activity. [Awesomeguy#Awesomeguy top]

===!InnerGameLoop===

The last complete class in the GameStart class is the InnerGameLoop class. This is an inner class extending a Thread. The 'run()' method contains the code that allows for progress in the game during game play.

The 'run()' method starts by initializing some values and instantiating some classes that are used later in the game. Then it starts a loop that executes as long as the game continues to be played. This 'play again' loop allows the user to automatically return to the beginning of the game when and if they run out of lives. This loop sets the starting level to '1' usually. (Normal game play starts with room 1, but a different starting room can be specified in the Options activity.) The 'run()' method records the value of the players previous score, then it sets the score of the current player to '10' since all games start with that score. The old score is remembered so that we can later tell if the player has beat their old score when  the game is over. Then we can save their new high score in the database table for high scores. 

Then the 'run()' method starts another loop that is responsible for advancing the player to the next level as the player completes the level that they are at. This loop allows the player to replay a level when they fail (die) if they have at least one life left. If they have no lives left the loop does not advance the player to the next level, but instead passes them over to the code at the end of the game (which tallies scores and checks to see if the player belongs on the high score table). Code in this loop also calls code responsible for initializing the level and placing all the objects and obstacles for a given level in the array that the graphics panel uses for displaying such things.

Another loop, inside the two mentioned above, is responsible for processing the actual user input and screen redrawing. This is the actual 'game play' loop. Every time through this loop a signal in the form of a Message is sent to the Handler, where the SurfaceView with the main game graphics in it is refreshed. This refreshing is done by the 'invalidate()' method, which must be called on that SurfaceView object from the Handler. In this loop is also a call to a game speed regulating function.

After the two inner loops exit, the program determines weather or not a player wants to continue playing, or weather they want to stop playing using an AlertDialog. If the second option is chosen, the alert dialog directs the user to another screen (not the GameStart activity) using an Intent. Otherwise, the program loops to the beginning of the first while statement. The three loop statements incorporate a boolean variable that, when set to true allows for the loops to continue, and when set to false exits the three loops. This is so that the game can be exited cleanly when the activity is quitting.

The InnerGameLoop class has two other methods. One is a public method called 'setGameRunning()' which sets the boolean described above that allows the various loops in the thread to exit. The other method is called 'gameSpeedRegualtor()' which is used to make sure that the periodic invalidate messages from the 'game play' loop are not issued too frequently. [Awesomeguy#Awesomeguy top]

===getSavedRoom() / saveRoom()===

Two methods in the GameStart.java file which are used by the 'onPause()' and 'onResume()' methods are 'saveRoomNo()' and 'getSavedRoom()'. These methods use the SharedPreferences android class to save the last room/level played by the user. They also load the room/level value from SharedPreferences for use in game play. As mentioned above, the desired starting level can be set in the Options activity. These two methods are not part of the InnerGameLoop class.

===onCreateDialog()===

The last part of GameStart.java, aside from some simple setters and getters, is the 'onCreateDialog(int id)' function. This is where the AlertDialog that asks the user if they want to continue playing the game is.

=!InitBackground java=

This class contains all the information needed to make a map that the Panel.java class uses to display the successive levels. The levels consist of a set of two dimensional arrays of 96x96 elements each.  One array is called the 'level' array and the other array is called the 'objects' array. The 'level' array defines the appearance of the background while the 'objects' array defines the how the game interprets solid objects and other objects like 'goals' and 'prizes'. The 'objects' array also describes the starting position of the player and all of the monsters.

Awesomeguy uses a tile system to display the different levels in the game. A tileset is loaded into the game at startup. The tileset is cut apart by the TileCutter in the Panel into 8x8 pixel squares. The squares are then placed on the screen in a pattern that is dictated by the 'level' array from the InitBackground class. This is how the appearance of every level is established. At the same time the second array, the 'objects' array, designates how each 8x8 square is treated by the game. This makes it possible to define 'solid' objects like walls and platforms. A square in the 'objects' array can be solid, or not solid. It can be a ladder, a prize (giving the player points), a goal (to advance to the next level), or a checkpoint (to mark how many levels the player has conquered). The array also holds the information for where all the monsters on the level are when the level starts, and the starting location of the player. The tile arrays can be a maximum of 96x96, and a position on one array directly coincides with the same position on the other array. Position (5,3) on the 'level' array holds information that is paired with position (5,3) on the 'objects' array. Each set of 'level' and 'object' arrays defines a complete Awesomeguy level. The arrays can be smaller than 96x96.

The arrays themselves can be created with a program called 'Mappy' that can be run on the Windows platform or on WINE if you are using Mac or Linux. Details for using Mappy are beyond the scope of this document, but essentially the Mappy program has a graphical editor where you can design the contents of the Awesomeguy level, and then you can output the two arrays to a text file in a C like format. 

To include the arrays in the InitBackground.java class you edit the text file slightly and then copy and past the array into the java xml file called awesomeguy.xml. Code to read the arrays from the xml file is located in the InitBackground.java file, along with the methods to decode the xml into the integer arrays that are required by the game. The xml file is located in the folder 'xml' that can be found in the project's 'res' folder.

The constructor takes a 'GameValues' object as a parameter. It also instantiates a 'ParseXML' object. The 'ParseXML' object is used later to extract the game information from the xml file.  [Awesomeguy#Awesomeguy top]

===initLevel()===

The second method is the 'initLevel()' method. This method is called after the two arrays have been established. The method first determines the starting point of the player by going through all the cells in the 'objects' table. Then the method determines the starting point of each of the monsters that might be on the level. As it finds these starting locations it adds each one to the ArrayList that has been set aside for sprites. This ArrayList is located in the GameValues object. The last thing that this method does is to call the function 'setStartingScrollPosition()'. [Awesomeguy#Awesomeguy top]

===setStartingScrollPosition()===

The next method is 'setStartingScrollPosition()' and it's job is to set the x and y scroll variables to their correct starting positions reflecting where the player actually starts from. The player cannot be off the screen when the level starts. If the player starts in the upper left-hand corner, as in the first level, then this function does nothing. If the player starts in the lower right hand of the level, as in the third level, then the function scrolls the background so that the player is visible when the game starts. [Awesomeguy#Awesomeguy top]

===setLevel()===

The next method in the class is called 'setLevel(int num)' and it takes an int as a parameter. The 'setLevel(int num)' function calls the xml parser and passes to the parser the num variable, which represents the level that the game requires next. The setLevel(int num) function is called before every level, and it's job is to pass the desired level number to the xml parser. [Awesomeguy#Awesomeguy top]

===testParse(int num)===

The xml parser method -- testParse(int num) -- takes the contents of the two arrays that are defined in the xml of the application and copies them to the area in the 'GameValues' object where all other parts of the program will look for that info during actual game play. The method uses 'if()' statements and 'while()' loops. Together they navigate through the xml and produce two strings of comma separated values. One string is for the visual information (called the mTiles String for this function) and one string is for the object information (called the mObjects String for this function). The two strings of comma separated values must contain exactly the same number of integers. 

Then the xml parsing program uses a java StringTokenizer to convert the comma separated values to the arrays used by the game. [Awesomeguy#Awesomeguy top]

=!GameValues java=

This class is mostly for holding variables that are used throughout the program that need to be in a central place and somewhat organized. It contains the two 2D arrays, 'level' and 'objects'. It also contains two variables that allow the game to function if the 2D arrays are smaller than 96x96. It contains constants for every kind of object that could be defined in the 'objects' array. It contains game progress variables, like 'room' for current room number, and booleans for weather the level is over or the game is over. It also contains the ArrayList for sprites, like the monsters, in the game. Most of the rest of the class is filled with setters and getters for these variables. [Awesomeguy#Awesomeguy top]

=!MovementValues java=

This class contains variables used for determining the movement of the main character from the input collected from the user. This input could be in the form of button presses on the screen or in some cases movement of the android trackball. It also holds the values of the scrollx and scrolly variables. Most of the class is made up of setters and getters, but there are two methods worth explaining. The 'getDirectionLR()' method returns a value for the user's input that eliminates the possibility that the 'left' and 'right' keys could be pressed at the same time. When the two keys are pressed together they cancel each other out. The method 'getDirectionUD()' works the same way for 'up' and 'down' keys. The class is also supposed to make it easier for the programmer to increase the distance that the player's character moves after a single button press. The default is three pixels, but conceivably this could be changed to another number easily. Trial and error would determine the final value. [Awesomeguy#Awesomeguy top]

=!SpriteInfo java=

The array list in the GameValues class that stores sprite information is populated with SpriteInfo objects. The SpriteInfo class contains information that might be useful to any part of the game that might want to display a sprite. Some of the info that's available in this class isn't used by all the sprites. The class is mostly filled with private int and boolean members and the setters and getters that are used to access them. The only special methods in the class are those that not only set the sprite info, but also increment or decrement it as well. The data members include resource ID, x and y position, width and height (not to be confused with BoundingBox), position on the screen, the sprite's true bounding box info, variables for weather or not the sprite is jumping and/or is animated. Also weather the sprite is 'facing right', weather it's visible, weather it's 'active' and what it's animation index is. [Awesomeguy#Awesomeguy top]

=!BoundingBox java=

BoundingBox.java has data and variables that help the game display and work with sprites. It contains private variables for the x and y location of the sprite in question, as well as variables called 'left', 'right', 'top', and 'bottom'. These values are ints and they define the portion of the printed sprite that's considered when the sprite is checked for collision with an object on the screen. This would be important when the player comes into contact with a ladder or a platform, for example. The bounding box of the sprite is defined by these four variables.

A simple constructor defines a default BoundingBox that has zero in all it's data members. Another constructor gives values to the four important data members (leaving the x and y as zero). [Awesomeguy#Awesomeguy top]

===makeSpriteBox()===

The next method in the class is a BoundingBox factory called 'makeSpriteBox()'. It takes a 'SpriteInfo' object as one input variable, and an x and y value as the other two. It is assumed for this method that Sprites can have various different dimensions depending on what kind of object they are. In practice, only the player's object is used by this factory.

===makeBlockBox()===

This is followed by another BoundingBox factory called 'makeBlockBox()'. It only takes x and y as inputs, because we can assume that all blocks have the same dimensions and the same bounding box, 8x8. 

===collisionSimple() ===

The next three methods are used to check weather one bounding box is actually in collision with another. This would happen if the two boxes touched or overlapped. That is what the three methods test. They are named 'collisionSimple(BoundingBox a)', 'collitionSimple(BoundingBox a, BoundingBox b)', and 'collisionHelper(BoundingBox a, BoundingBox b)'. One is a convenience function, one is a helper function. Therefore there is essentially only one method that actually does collision detection, the version 'collisionSimple(BoundingBox a, BoundingBox b)'. [Awesomeguy#Awesomeguy top]

===getCenterBlock()===

The last function of substance in the BoundingBox file is one called 'getCenterBlock(BoundingBox a)'. This function returns the int that is associated with the block that is directly in the center of the BoundingBox specified. It is used to find the block directly below the player during game play. The screen coordinates and the map coordinates are not the same, and the difference between the two needs to be addressed. The player's coordinates are 8 times bigger than the player's position on the map. The player also has dimensions that are stored in it's bounding box, and these have to be considered when you try to determine weather the player is standing on a block, for example. The rest of the file is filled with setters and getters for the various private integers in the class. [Awesomeguy#Awesomeguy top]

=Panel java=

When the game is being played, one instance of the Panel.java class is displayed on the android screen. The top screen always displays the level of the game that is being played. The Panel.java class is a SurfaceView, and a SurfaceView is an extended View. Views are the basic building blocks of user interfaces in android apps. They are used to hold text, buttons, and other user interface items but they also have an 'onDraw(...)' method for drawing 2D graphics in their borders. SurfaceViews have the same 'onDraw(...)' method. In the SurfaceView 'onDraw(...)' method is a Canvas object, which is important for doing this drawing. 

Awesomeguy originally used two separate methods for drawing the game's graphics on the screen. With one method the game used pure Java to draw it's components. With the other method the game used a special C library, called a JNI library. JNI stands for "Java Native Interface". The JNI code will be discussed later. Because of speed considerations the purely Java graphics engine for Awesomeguy was removed and only the JNI version was retained. [Awesomeguy#Awesomeguy top]

===Drawing===

In this game when graphics were being displayed by Java we used the Canvas 'drawBitmap(...)' function repeatedly inside the 'onDraw()' method. Each of the tiles we put on the screen and also each of the sprite images uses the 'drawBitmap(...)' function. This was very slow. A View also has a 'scrollTo(...)' method that allows the drawing being done to be scrolled inside the boundaries of the View. This is inherited by the SurfaceView and is used by the game's Panel class. When we are using JNI functions to display the game's graphics, the program uses 'drawBitmap(...)' and 'scrollTo(...)' much less. It uses 'drawBitmap(...)' once for every time the screen is refreshed. The JNI code loads the game's graphics when the Panel class is instantiating, not during game play. In the JNI the graphic images, in the form of arrays, are copied to an area of memory that represents the game screen. Then, once in every refresh, the screen array is converted to a bitmap and printed in it's entirety to the game screen where the player can see it. This is an improvement over the Java version that drew to the screen hundreds of small bitmaps to make the final visible game screen. The JNI code will be discussed in detail later. 

During the GameStart Activity there is always a Panel on the screen that is displaying the game's graphics. When the panel is invalidated by the GameStart code, the screen is re-drawn and the game takes into account all the changes that have happened during the period of inactivity. One of the main roles of the GameStart code is just to invalidate the Panel class. If this loop of invalidation happens quickly enough the game's elements seem to be animated. Invalidating the Panel cannot be done from a thread that did not start the Panel - android will return an error on the debugger console and the program will quit. This is why the GameStart Activity contains a 'mHandler'. This is a device provided by the android operating system for updating the Panel without being in it's thread. It is a queue. [Awesomeguy#Awesomeguy top]

===Panel() Constructor===

The first method in the Panel class is the constructor. In the constructor we pass six items. The first is a Context object, which we immediately 'super' to the default constructor with the line 'super(context);'. The next item passed in the constructor is a reference to the GameValues object, which stores the 'level' and 'object' arrays, as well as the ArrayList for the SpriteInfo objects. The next thing in the constructor signature is a reference to the GameStart object, which is the Panel's parent. The next thing in the constructor signature is the MovementValues object, which holds all info collected from the user about where he or she would like the game's character to move. Finally the Record of the current user (their high scores, etc.) and the screen display width are passed in the constructor. Inside the constructor several variables are initialized, including several Bitmap objects, a Paint object, and the initial values of the scroll variables. The arrays for the JNI code that hold the data from the various bitmaps are loaded here. The array data is also passed to the JNI library here. [Awesomeguy#Awesomeguy top]

===onDraw()===

The second method in the Panel class is the 'onDraw(...)' method. The method takes one parameter, the Canvas object for the SurfaceView class, which the android system passes to the function automatically. The programer must override the 'onDraw(...)' method, using the canvas supplied by the android OS to draw the content that he or she desires. 

The 'onDraw(...)' method proceeds to draw the game info. First it passes the current 'score' and 'lives' values to the JNI library with a method called 'setScoreLives(...)'. Then it calls four functions. The four calls are 'checkRegularCollision()', 'checkPhysicsAdjustments()', 'collisionWithMonsters()' and 'scrollBg()'. These four methods are somewhat self explanatory, but they will be described in the section below. Essentially they figure out where the character is on the level, and if he's encountered any obstacles. As a result the GameValues values represent the new position of the character and the new position of the background.

Next the 'animateItems()' function is called. This function is part of the Panel class. It helps to animate the main sprite and the monster sprites by skipping a few frames before every change in the sprite image. Without the 'animateItems()' function the sprites would be animated almost too fast to see. There are four images for the main character and four images of the monster character (two for left and two for right).

Next the canvas is used to draw the black background on the entire contents of the SurfaceView. Then, three lines print the JNI library's output on the screen. 

{{{
	mMap = Bitmap.createBitmap(drawLevel(newBG + 1), 256, 192, Bitmap.Config.RGB_565);
	mTempJNI = Bitmap.createBitmap(mMap, 0, 0, 256, 192, mMatrix, false);
	canvas.drawBitmap(mTempJNI, 0, 0, null);
}}}

The first line takes the output of the code `drawLevel(newBG + 1)` and turns it into a bitmap called mMap. The function 'drawLevel(...)' is part of the JNI library. It returns an array of java int data. 'Bitmap.createBitmap(...)' turns this data array into a proper bitmap.

The second line takes the mMap bitmap and doubles it's size so that it fits better on larger screens. The mMatrix object is where you specify the size you want the resulting bitmap to be. We choose to double the size.

The last line, 'canvas.drawBitmap(mTempJNI, 0, 0, null)' prints the new Bitmap on the screen. This is how we get our JNI array to show on the screen. The crucial line is the 'createBitmap(...)' function that takes a java array as one of it's parameters. 


Lastly in the onDraw() method a group of statements checks to see if the game is over and if the 'score' and 'lives' have changed. Since the JNI code keeps track of these things separately this code is necessary.  [Awesomeguy#Awesomeguy top]

===setInitialBackgroundGraphics()===

This function is called by the Handler in GameStart.java when the level is starting. It sets the scrollX and scrollY variables, which dictate the scroll position of the game screen during play. This basically sets the scroll position that the background is set to if the awesomeguy sprite is not in the upper left hand corner when the game starts. The function also initializes the awesomeguy character's sprite. This entails clearing out the ArrayList that the sprites are stored in and saving the character as the very first entry in a new list. Then the character's sprite is adjusted for it's proper starting position, and the global Panel.java variables for the character's x and y position are set. These two variables are called guyX and guyY. [Awesomeguy#Awesomeguy top]

===setGameValues() / getGameValues()===

This simple setter/getter pair is used to reset the Panel.java global 'mGameV', or return a pointer to the one that the Panel.java class is already using. A reference to a GameValues class is also passed to the Panel.java class in the constructor.

===setPanelScroll()===

This function is used repeatedly to set the scrollX and scrollY variables during game play. Since it's called with every refresh of the Panel SurfaceView, it is also used for other purposes. The setGuyPosition() function called here, with parameters that include the character's x and y position, the screen's scrollX and scrollY, and the animation index for the main character. [Awesomeguy#Awesomeguy top]

===animateItems()===

This function keeps track of two indexes for animating the character sprite and also the tilesheet animation. There are eight possible values for the tilesheets and four for the main character.


===checkPhysicsAdjustments()===

This code is used by both the Java and the JNI versions of the program. The lines in this function check weather or not the main character is falling, jumping, running, climbing, etc., and they are only concerned with the contents of the 'objects' tilemap table. The code takes the user input and figures out weather the character can move in the direction desired. Gravity is implemented here, so that the character has a tendency to move twords the bottom of the screen (if that movement is not impeded by obstacles). It's probably because gravity is implemented here that the method has the name that it does.

Other methods are called in this code, and the order they're called in is sometimes important. Methods that check collision with blocks are called here. This way the character can stand on platforms. Jumping is also handled here, as is climbing on ladders.

===collisionWithBlocks()===

This method is called by the 'checkPhysicsAdjustments()' function. It attempts to anticipate every possible interaction the main character can have with blocks and define an action to take to address that contact. For this reason the method is long, and contains lines that duplicate the basic principle of the lines above them, differing only in the direction the character is traveling in when it comes in contact with these blocks. Also found here are the lines of code that allow the character to 'hop' or 'skip' over a single block if it is alone in their path. This way the character can climb a gradual increase in height without jumping.

Blocks, in the context of this function, are defined in the 'objects' tilemap table only. Here, as in the 'checkPhysicsAdjustments()' method, the 'level' tilemap table is unimportant.

===collisionWithPlatforms()===

This method is also called by the 'checkPhysicsAdjustments()' function. It concerns itself with what happens when the main character comes into contact with a floating platform. The function looks at the list of sprites and determines which sprites in the list represent floating platforms. Then it goes through this portion of the sprite list checking the position of the sprite with respect to the position of the character. Specifically, if the BoundingBox of the main character intersects the bounding box of the platform, the 'canFall' variable is set to false, and the character is moved, by adjusting it's x variable, in the same direction as the platform.

The interesting thing to note here is that the JNI has a separate list of sprites, and the JNI is responsible for putting these sprites on the screen. Therefore the list of platform sprites that the JNI has must be synchronized somehow with the list that the Java 'collisionWithPlatforms()' function uses. This is done with a series of JNI methods that appear in the code like this:

{{{
	/* loop through platform sprite records */
	for (i = mGameV.getPlatformOffset() + 1 ; i <=  mGameV.getPlatformNum() ; i ++) {
		j = i ; //j could be adjusted here
		/* get info from JNI on platform position */
		SpriteInfo mTempSprite = new SpriteInfo( 0, 8, 0, 40);
		    
		mTempSprite.setMapPosX(this.getSpriteX(j));
		mTempSprite.setMapPosY(this.getSpriteY(j));
		if(this.getSpriteFacingRight(j) == 1) mFacingRight = true;
		else mFacingRight = false;
		mTempSprite.setFacingRight(mFacingRight);

		/* code skipped here for brevity */

	}
}}}

The methods 'getSpriteX()', 'getSpriteY()', and 'getSpriteFacingRight()' all return info on a given sprite. The methods are passed an index number, the index number of the sprite for which we want information, and they return from the JNI the integer value that corresponds to the requested values for the sprite struct from the JNI's sprite list array (as opposed to the Java ArrayList of SpriteInfo objects).

Because the Java ArrayList of SpriteInfo objects contains sprites for the main character as well as the monsters that might be visible on a level, the for(...) loop uses mGameV.getPlatformOffset() and mGameV.getPlatformNum() to help define the index numbers that the function focuses on. These two variables are set when the level is initialized and the platform SpriteInfo objects are placed in the ArrayList. 

In the ArrayList for sprites in the Java code the first record is the main character's sprite. The second record starts a list of all the monsters on the level. The last monster is followed by all the moving platforms on the level. The GameValues Object includes variables for the start and end of the monster portion of the list, and also variables for the start and end of the platform portion of the list. In the JNI code, the sprite struct is stored in an array. The contents of this array are similar to the ArrayList in the Java code, except the main character doesn't appear in the list. It holds just monsters and platforms, and the main character's sprite is kept in a separate struct all on it's own. When querying the JNI for sprite info we have to be aware of the difference between the two lists and that is why the 'j' variable is included in the listing above.

===scrollBg()===

This method takes into account the size of the level and the size of the actual screen, as well as the position of the character and which direction he intends to move, and produces the scroll position of the background and the new position of the character.

It has if() blocks for movement in each of the four dimensions. Inside the if() blocks it is determined weather or not the character moves (when traveling near the edges of the screen) or if the background moves, giving the character the _appearance_ of movement. In the latter case, the background can be moved only if it is bigger than the screen that's displayed, and only if the edge of the background is not aligned with the edge of the screen alreay.

===checkRegularCollisions()===

Here we create a BoundingBox for the guy character. Then we loop through the 'objects' array and make a BoundingBox for each cell in the array. We check to see if the character is in collision with any of the squares in the array. If it is we see what kind of object it is and then act accordingly.

For a ring, we give the character a certain amount of points and then we erase the ring's object number from the array, making it disappear. If it is the goal we end the level and play a sound.

To make the code more efficient, we don't check the whole array every time the screen refreshes. Instead we check the array elements that immediately surround the character.

{{{
int i,j;

for (j =  mGuySprite.getMapPosX() / 8 -1; j <  mGuySprite.getMapPosX() / 8 + 3; j ++ ) { 
	for (i = mGuySprite.getMapPosY() / 8 - 1; i < mGuySprite.getMapPosY() / 8 + 3; i ++ ) { 
		if(j >= 0 && j < mGameV.getMapH()  && i >= 0 && i < mGameV.getMapV()) {

			if (mGameV.getObjectsCell(j,i)  != 0 ) { 


				BoundingBox testMe = BoundingBox.makeBlockBox(j,i);

				boolean test = BoundingBox.collisionSimple(guyBox, testMe);



				/********  solid block *****/
				if (test && mGameV.getObjectsCell(j, i) == mGameV.mBlock) {
					blockTest = true;

				}
				/******** ladder **********/
				if (test && mGameV.getObjectsCell(j,i) == mGameV.mLadder) {
					ladderTest = true;

				}
				/****** more tests here ******/
			} // if block

		} // indexes OK?
		else {

			/* some boundary checking tests here */

		}
	} // i block
} // j block


}}}