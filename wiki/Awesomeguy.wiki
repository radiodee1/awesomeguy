#summary Awesomeguy is a computer game for the Android 2.1/2.2 phone.

= Introduction =

Awesomeguy is a computer game originally developed for the Nintendo DS game system that I am attempting to port to the Android platform. 

= Details =

The format of the Awesomeguy game is that of a simple platform game, in some ways like the original “Donkey Kong” or “Super Mario Brothers”. The Nintendo DS version has two screens of 192x256 pixels each. During gameplay one of the screens was generally used as a splash screen. The game also makes use of four directional keys and two special keys -- one of which is the 'jump' key.

The android phone that the game was developed for had no "D-pad". For the android version, two separate View objects were required during regular game play. One View was for display of the game screen, the equivalent of the main screen from the Nintendo game, and the other View was the emulated "D-pad". The "D-pad" was emulated using TouchButtons on the touch screen and also an alternative where movement instructions were taken from the trackball. The DS version of the game uses several large int arrays for keeping track of the appearance of each level in the game. In order to port the levels to the android version, the same sort of array was used in the android code. In this way the android version can use the exact same level definition info. The android version also uses an ArrayList to keep track of sprite data, though sprites are not hardware supported in java. One ArrayList is used for all types of sprites. The DS version makes use of a set of four tiles that are used to paint the levels from the predefined level array on the game screen. The same tile set was used in the android version, but software was used to emulate the DS's hardware tiling system. For these reasons the android version of the game is slower to play than the homebrew DS version.

----

=!AndroidManifest.xml=

The AndroidManifest.xml file has entries for each of the game's activities. In the xml entry for the SplashScreen activity, the values for 'clearTaskOnLaunch' are set to 'true', and the values for 'launchMode' are set to 'singleTask'. This arrangement is shown in the following snippet. The 'clearTaskOnLaunch' option is what allows the game to always restart with the Splash Screen regardless of what state it was in when it was stopped. This option was used in each of the activities in the xml file.

{{{
<activity android:name=".SplashScreen"
android:label="@string/app_name"
android:clearTaskOnLaunch="true"
android:launchMode="singleTask">
}}}

For each of the activities of the application I put 'clearTaskOnLaunch' as one of the xml parameters (as noted above).

{{{
<activity android:name=".Menu"
android:clearTaskOnLaunch="true">
}}}


=!SplashScreen.java=

When the game starts the user is presented with a splash screen that dismisses itself when the user presses the screen or when a certain amount of time has passed. The splash screen activity performs certain tasks when it displays. One thing that it does is initializing the database that holds the player scores. It also creates a new blank player record for storing high scores and user preferences. (It doesn't give this new record a user name -- that's saved for if the user decides to do so). Then it sets the default starting level to '1'. This way if the game is started without the user expressing their preference, the starting room number will be '1'.

=Menu.java=

The next thing that the user sees is a menu. This menu allows the user to view a 'help' or 'credits' file, enter 'options' that effect game play and the way scores are saved, go to a 'players' selection screen, or simply 'play game'.  The last option forwards the user to the actual game. Each of the options on the menu launches another android Activity. The AndroidManifest.xml file is set up to ensure that the game starts over at the splash screen whenever it exits normally.



=!GameStart.java=

Game play is handled by the GameStart.java activity. The first thing that happens in the activity is that the screen is drawn. Layout of the screen is handled using code and not an xml file. The screen is roughly divided into two sections. There is a top panel for the actual display of the game while the user is playing, and there is the area below the top screen which is where buttons appear for controlling the movement of the game's main character. The top screen is an instantiation of a Panel.java class, which is a SurfaceView. Layout elements are all assembled in the 'onCreate()' method of the GameStart activity. One of the first things that's done when assembling the Views on the screen is to measure the size of the display. This is done with code like this:

{{{
Display display = ((WindowManager) getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();    	
int mDimension = display.getWidth();
}}}
This width dimension is used to size the game screen and the touch buttons. A separate function is used to construct the touch button part of the screen. This function is called 'getGamePad(int width)' and it returns an entire TableLayout already filled with all the necessary buttons. Two types of buttons are used, one called a BlankButton and one called a TouchButton. Both kinds of buttons are inner classes in the GameStart.java file, and they both extend the android 'Button' type. The TouchButton also implements the 'View.OnTouchListener' interface, which allows the program to respond to user input.

===onPause()===

The 'onPause()' method of the GameStart.java activity waits for the game loop to exit. The 'onPause()' method sends a message to the InnerGameLoop thread to exit all loops, and then the 'join()' command waits for the thread to finish. It also saves the high scores for the current player to the high score database.

===onResume()===

The 'onResume()' method of the GameStart.java activity begins by retrieving from the SharedPreferences the user record for the current user. This is so that if the user made changes to their game play experience using the 'Players' menu or the 'Options' menu, then those changes could be referenced in the 'GameStart' activity. The method 'onResume()' also finishes the job of building the game controls and adding them to the View that the game is displayed in. It also starts a separate thread called the InnerGameLoop. This Thread is a inner java class which is found in the body of the GameStart class. It is used to help process user input and direct the SurfaceView to refresh when it is necessary. The 'onResume()' method also instantiates a new InitBackground.java class. This class loads the definition information for each new level. Info about the shape of each level and the placement of various objects in the game (like rings and lives) are loaded in this object. 

===TouchButton===

Next in the GameStart.java class is the inner class that describes the object called TouchButton. The TouchButton extends the regular android Button class and is used in the 'getGamePad( int x )' method when the game's movement and jump buttons are created. Five times this variant of the android Button class is used. The TouchButton class implements 'View.onTouchListener', which allows the buttons to detect pressure from the touch screen. The touch buttons use the MotionEvent.ACTION_DOWN and MotionEvent.ACTION_UP constants in the 'onTouch()' method to detect key presses. Then the value for the key (up, down, left, right, etc.) is passed to the functions that process this key input, functions that are part of the MovementValues and the Panel classes respectively.

There is one particularly useful constructor in the TouchButton class. There are seven parameters to the constructor. They set the button's context, background resource, width, and height. They also set the values in the TouchButton that show which 'direction' the button represents (a constant for up, down, left, right, and B) and an optional string that can be used for identification purposes. The TouchButton is also set up to receive input from the trackball. All TouchButton buttons are listening for trackball input. The code to include trackball input is incorporated in the 'View.OnKeyListener()' object, which is an anonymous class in the TouchButton constructor code. 

===BlankButton===

Another inner class in the GameStart.java file is the 'BlankButton'. This button is the same height and width of the TouchButton, but has no event listeners. It's used to fill in the spaces between the more important TouchButtons in 'getGamePad(int num)'

===mHandler===

Next in the GameStart.java class is the inner class defining the Handler 'mHandler'. This class sets up a queue for processing events in the program. It's especially useful for updating the Panels that contain the graphical information for the game. These panels can only be updated from the thread that started them, so the InnerGameLoop thread, described below, can only request that the screen be redrawn by using this queue device as it exists in a separate thread. Message objects are sent by different classes in the application to the Handler, which puts each message on the queue -- usually in the order they were recieved. Types of messages are defined as static final ints at the beginning of the GameStart class. It also has a use when we are trying to launch an AlertDialog from inside the InnerGameLoop. This too can only be done from the original thread of the GameStart activity.

===InnerGameLoop===

The last complete class in the GameStart class is the InnerGameLoop class. This is an inner class extending a Thread. The 'run()' method contains the code that allows for progress in the game during game play.

The 'run()' method starts by initializing some values and instantiating some classes that are used later in the game. Then it starts a loop that executes as long as the game continues to be played. This 'play again' loop allows the user to automatically return to the beginning of the game when and if they run out of lives. This loop sets the starting level to '1' usually. (Normal game play starts with room 1, but a different starting room can be specified in the Options activity.) The 'run()' method records the value of the players previous score, then it sets the score of the current player to '10' since all games start with that score. The old score is remembered so that we can later tell if the player has beat their old score when  the game is over. Then we can save their new high score in the database table for high scores. 

Then the 'run()' method starts another loop that is responsible for advancing the player to the next level as the player completes the level that they are at. This loop allows the player to replay a level when they fail (die) if they have at least one life left. If they have no lives left the loop does not advance the player to the next level, but instead passes them over to the code at the end of the game (which tallies scores and checks to see if the player belongs on the high score table). Code in this loop also calls code responsible for initializing the level and placing all the objects and obstacles for a given level in the array that the graphics panel uses for displaying such things.

Another loop, inside the two mentioned above, is responsible for processing the actual user input and screen redrawing. This is the actual 'game play' loop. Every time through this loop a signal in the form of a Message is sent to the Handler, where the SurfaceView with the main game graphics in it is refreshed. This refreshing is done by the 'invalidate()' method, which must be called on that SurfaceView object from the Handler. In this loop is also a call to a game speed regulating function.

After the two inner loops exit, the program determines weather or not a player wants to continue playing, or weather they want to stop playing using an AlertDialog. If the second option is chosen, the alert dialog directs the user to another screen (not the GameStart activity) using an Intent. Otherwise, the program loops to the beginning of the first while statement. The three loop statements incorporate a boolean variable that, when set to true allows for the loops to continue, and when set to false exits the three loops. This is so that the game can be exited cleanly when the activity is quitting.

The InnerGameLoop class has two other methods. One is a public method called 'setGameRunning()' which sets the boolean described above that allows the various loops in the thread to exit. The other method is called 'gameSpeedRegualtor()' which is used to make sure that the periodic invalidate messages from the 'game play' loop are not issued too frequently.

===getSavedRoom() / saveRoom()===

Two methods in the GameStart.java file which are used by the 'onPause()' and 'onResume()' methods are 'saveRoomNo()' and 'getSavedRoom()'. These methods use the SharedPreferences android class to save the last room/level played by the user. They also load the room/level value from SharedPreferences for use in game play. As mentioned above, the desired starting level can be set in the Options activity. These two methods are not part of the InnerGameLoop class.

===onCreateDialog()===

The last part of GameStart.java, aside from some simple setters and getters, is the 'onCreateDialog(int id)' function. This is where the AlertDialog that asks the user if they want to continue playing the game is.

=!InitBackground.java=

This class contains all the information needed to make a map that the Panel.java class uses to display the successive levels. The levels consist of a set of two dimensional arrays of 96x96 elements each.  One array is called the 'level' array and the other array is called the 'objects' array. The 'level' array defines the appearance of the background while the 'objects' array defines the how the game interprets solid objects and other objects like 'goals' and 'prizes'. The 'objects' array also describes the starting position of the player and all of the monsters.

Awesomeguy uses a tile system to display the different levels in the game. A tileset is loaded into the game at startup. The tileset is cut apart by the TileCutter in the Panel into 8x8 pixel squares. The squares are then placed on the screen in a pattern that is dictated by the 'level' array from the InitBackground class. This is how the appearance of every level is established. At the same time the second array, the 'objects' array, designates how each 8x8 square is treated by the game. This makes it possible to define 'solid' objects like walls and platforms. A square in the 'objects' array can be solid, or not solid. It can be a ladder, a prize (giving the player points), a goal (to advance to the next level), or a checkpoint (to mark how many levels the player has conquered). The array also holds the information for where all the monsters on the level are when the level starts, and the starting location of the player. The tile arrays can be a maximum of 96x96, and a position on one array directly coincides with the same position on the other array. Position (5,3) on the 'level' array holds information that is paired with position (5,3) on the 'objects' array. Each set of 'level' and 'object' arrays defines a complete Awesomeguy level. The arrays can be smaller than 96x96.

The arrays themselves can be created with a program called 'Mappy' that can be run on the Windows platform or on WINE if you are using Mac or Linux. Details for using Mappy are beyond the scope of this document, but essentially the Mappy program has a graphical editor where you can design the contents of the Awesomeguy level, and then you can output the two arrays to a text file in a C like format. 

To include the arrays in the InitBackground.java class you edit the text file slightly and then copy and past the array into the java xml file called awesomeguy.xml. Code to read the arrays from the xml file is located in the InitBackground.java file, along with the methods to decode the xml into the integer arrays that are required by the game. The xml file is located in the folder 'xml' that can be found in the project's 'res' folder.

The constructor takes a 'GameValues' object as a parameter. It also instantiates a 'ParseXML' object. The 'ParseXML' object is used later to extract the game information from the xml file. 

The second method is the 'initLevel()' method. This method is called after the two arrays have been established. The method first determines the starting point of the player by going through all the cells in the 'objects' table. Then the method determines the starting point of each of the monsters that might be on the level. As it finds these starting locations it adds each one to the ArrayList that has been set aside for sprites. This ArrayList is located in the GameValues object. The last thing that this method does is to call the function 'setStartingScrollPosition()'.

The next method is 'setStartingScrollPosition()' and it's job is to set the x and y scroll variables to their correct starting positions reflecting where the player actually starts from. The player cannot be off the screen when the level starts. If the player starts in the upper left-hand corner, as in the first level, then this function does nothing. If the player starts in the lower right hand of the level, as in the third level, then the function scrolls the background so that the player is visible when the game starts.

The next method in the class is called 'setLevel(int num)' and it takes an int as a parameter. The 'setLevel(int num)' function calls the xml parser and passes to the parser the num variable, which represents the level that the game requires next. The setLevel(int num) function is called before every level, and it's job is to pass the desired level number to the xml parser.

The xml parser method takes the contents of the two arrays that are defined in the xml of the application and copies them to the area in the 'GameValues' object where all other parts of the program will look for that info during actual game play. The method uses 'if()' statements and 'while()' loops. Together they navigate through the xml and produce two strings of comma separated values. One string is for the visual information (called the mTiles String for this function) and one string is for the object information (called the mObjects String for this function). The two strings of comma separated values must contain exactly the same number of integers. 

Then the xml parsing program uses a java StringTokenizer to convert the comma separated values to the arrays used by the game. The name of the function that is responsible for all of this is 'testParse(int num)'. 

=!GameValues.java=

This class is mostly for holding variables that are used throughout the program that need to be in a central place and somewhat organized. It contains the two 2D arrays, 'level' and 'objects'. It also contains two variables that allow the game to function if the 2D arrays are smaller than 96x96. It contains constants for every kind of object that could be defined in the 'objects' array. It contains game progress variables, like 'room' for current room number, and booleans for weather the level is over or the game is over. It also contains the ArrayList for sprites, like the monsters, in the game. Most of the rest of the class is filled with setters and getters for these variables.

=!MovementValues.java=

This class contains variables used for determining the movement of the main character from the input collected from the user. This input could be in the form of button presses on the screen or in some cases movement of the android trackball. It also holds the values of the scrollx and scrolly variables. Most of the class is made up of setters and getters, but there are two methods worth explaining. The 'getDirectionLR()' method returns a value for the user's input that eliminates the possibility that the 'left' and 'right' keys could be pressed at the same time. When the two keys are pressed together they cancel each other out. The method 'getDirectionUD()' works the same way for 'up' and 'down' keys. The class is also supposed to make it easier for the programmer to increase the distance that the player's character moves after a single button press. The default is three pixels, but conceivably this could be changed to another number easily. Trial and error would determine the final value.

=!SpriteInfo.java=

The array list in the GameValues class that stores sprite information is populated with SpriteInfo objects. The SpriteInfo class contains information that might be useful to any part of the game that might want to display a sprite. Some of the info that's available in this class isn't used by all the sprites. The class is mostly filled with private int and boolean members and the setters and getters that are used to access them. The only special methods in the class are those that not only set the sprite info, but also increment or decrement it as well. The data members include resource ID, x and y position, width and height (not to be confused with BoundingBox), position on the screen, the sprite's true bounding box info, variables for weather or not the sprite is jumping and/or is animated. Also weather the sprite is 'facing right', weather it's visible, weather it's 'active' and what it's animation index is.

=!BoundingBox.java=

BoundingBox.java has data and variables that help the game display and work with sprites. It contains private variables for the x and y location of the sprite in question, as well as variables called 'left', 'right', 'top', and 'bottom'. These values are ints and they define the portion of the printed sprite that's considered when the sprite is checked for collision with an object on the screen. This would be important when the player comes into contact with a ladder or a platform, for example. The bounding box of the sprite is defined by these four variables.

A simple constructor defines a default BoundingBox that has zero in all it's data members. Another constructor gives values to the four important data members (leaving the x and y as zero).

The next method in the class is a BoundingBox factory called 'makeSpriteBox()'. It takes a 'SpriteInfo' object as one input variable, and an x and y value as the other two. It is assumed for this method that Sprites can have various different dimensions depending on what kind of object they are. In practice, only the player's object is used by this factory.

This is followed by another BoundingBox factory called 'makeBlockBox()'. It only takes x and y as inputs, because we can assume that all blocks have the same dimensions and the same bounding box, 8x8. The next three methods are used to check weather one bounding box is actually in collision with another. This would happen if the two boxes touched or overlapped. That is what the next three methods test. They are named 'collisionSimple(BoundingBox a)', 'collitionSimple(BoundingBox a, BoundingBox b)', and 'collisionHelper(BoundingBox a, BoundingBox b)'. The last one is a helper for the middle one.

The last function of substance in the BoundingBox file is one called 'getCenterBlock(BoundingBox a)'. This function returns the int that is associated with the block that is directly in the center of the BoundingBox specified. It is used to find the block directly below the player during game play. The screen coordinates and the map coordinates are not the same, and the difference between the two needs to be addressed. The player's coordinates are 8 times bigger than the player's position on the map. The player also has dimensions that are stored in it's bounding box, and these have to be considered when you try to determine weather the player is standing on a block, for example. The rest of the file is filled with setters and getters for the various private integers in the class.

=Panel.java=

When the game is being played, two instances of the Panel.java class are displayed on the android screen. The top screen always displays a splash screen type image, and the bottom screen always displays the level of the game that is being played. This mirrors the game play experience on the Nintendo DS. The Panel.java class is a SurfaceView, and a SurfaceView is an extended View. Views are the basic building blocks of user interfaces in android apps. They are used to hold text, buttons, and other user interface items but they also have an 'onDraw(...)' method for drawing 2D graphics in their borders. SurfaceViews have the same 'onDraw(...)' method. In the SurfaceView 'onDraw(...)' method is a Canvas object, which is important for doing this drawing. In this game when graphics are being displayed by Java we use the Canvas 'drawBitmap(...)' function repeatedly. Each of the tiles we put on the screen and also each of the sprite images uses the 'drawBitmap(...)' function. A View also has a 'scrollTo(...)' method that allows the drawing being done to be scrolled inside the boundaries of the View. This is inherited by the SurfaceView and is used by the game's Panel class. When we are using JNI functions to display the game's graphics, the program uses 'drawBitmap(...)' and 'scrollTo(...)' much less frequently. In this section we'll discuss the Java code, and in another section we'll discuss the JNI code.

During the GameStart Activity there is always a Panel on the screen that is displaying the game's graphics. When the panel is invalidated by the GameStart code, the screen is re-drawn and the game takes into account all the changes that have happened during the period of inactivity. One of the main roles of the GameStart code is just to invalidate the Panel classes. If this loop of invalidation happens quickly enough the game's elements seem to be animated. Invalidating the Panel cannot be done from a thread that did not start the Panel - android will return an error on the debugger console and the program will quit. This is why the GameStart Activity contains a 'myPanelUpdateHandler'. This is a device provided by the android operating system for updating the Panel without being in it's thread. It is a queue.

The first method in the Panel class is the constructor. In the constructor we pass four items. The first is a Context object, which we immediately 'super' to the default constructor with the line 'super(context);'. The next item passed in the constructor is a reference to the GameValues object, which stores the 'level' and 'object' arrays, as well as the ArrayList for the SpriteInfo objects. The next thing in the constructor signature is a reference to the GameStart object, which is the Panel's parent. The last thing in the constructor signature is the MovementValues object, which holds all info collected from the user about where he or she would like the game's character to move. Inside the constructor several variables are initialized, including several Bitmap objects, a Paint object, and the initial values of the scroll variables, as well as an instantiation of a GameLoopFunctions object. There is also a variable called 'message' that holds an int which the Panel uses to decide exactly what to draw.

The second method in the Panel class is the 'onDraw(...)' method. The method takes on parameter, the Canvas object for the SurfaceView class, which the android system passes to the function automatically. The programer must override the 'onDraw(...)' method, using the canvas supplied by the android OS to draw the content that he or she desires. In the Panel class the first thing that happens is the program checks to see if the Panel is the top or the bottom. If it is the top, the 'message' variable holds a constant that tells the 'onDraw()' method not to draw the game play data but to draw one of several splash screen images. The constant is defined in the GameValues class.

If the Panel is the bottom SurfaceView, then the 'onDraw(...)' method proceeds to draw the game info. First it calls three functions from GameLoopFunctions. The three calls are 'checkRegularCollision()', 'physicsAdjustments()', and 'scrollBg()'. The three methods are somewhat self explanatory, but they will be described in the 'GameLoopFunctions' section below. Essentially they figure out where the character is on the level, and if he's encountered any obstacles. As a result the GameVariable values represent the new position of the character and the new position of the background.

Next the 'animateItems()' function is called. This function is part of the Panel class. It helps to animate the main sprite and the monster sprites by skipping a few frames before every change in the sprite image. Without the 'animateItems()' function the sprites would be animated almost too fast to see. There are four images for the main character and four images of the monster character (two for left and two for right).

Next the canvas is used to draw the black background on the entire contents of the SurfaceView. Then a loop is used to step through the two dimensional 'level' array and determine what kind of tile goes in each position on the screen. A TileCutter object is used here to take the predefined tile set and break it apart into smaller pieces. Those individual tiles are used to draw the level itself. Since the background scrolls, the loops are arranged so that they only draw tiles in positions that would be visible at that time.