#summary Method by method explanation of the 'awesomeguy.c' file.
#sidebar TableOfContents
= Introduction =

Here we'll go through a method by method explanation of the 'awesomeguy.c' file, as well as talk a little about how we might have implemented Awesomeguy's graphics in java. First, though, we'll repeat some information from another wiki that describes Awesomeguy's graphics.

<wiki:toc max_depth="5" />

=Overview=

The format of the Awesomeguy game is that of a simple platform game, in some ways like the original “Donkey Kong” or “Super Mario Brothers”. The Nintendo DS version has two screens of 192x256 pixels each. During gameplay one of the screens was generally used as a splash screen. The game also makes use of four directional keys and two special keys -- one of which is the 'jump' key. 

The android phone that the game was developed for had no "D-pad". For the android version, two separate View objects were required during regular game play. One View was for display of the game screen, the equivalent of the main screen from the Nintendo game, and the other View was the emulated "D-pad". The "D-pad" was emulated using TouchButtons? on the touch screen and also an alternative where movement instructions were taken from the trackball. The DS version of the game uses several large int arrays for keeping track of the appearance of each level in the game. In order to port the levels to the android version, the same sort of array was used in the android code. In this way the android version can use the exact same level definition info. The android version also uses an ArrayList? to keep track of sprite data, though sprites are not hardware supported in java. One ArrayList? is used for all types of sprites. The DS version makes use of a set of four tiles that are used to paint the levels from the predefined level array on the game screen. The same tile set was used in the android version, but software was used to emulate the DS's hardware tiling system. For these reasons the android version of the game is slower to play than the homebrew DS version.

===Tilesheets===

Tilesheets are very important to the Awesomeguy game. Tilesheets do not exist natively in the Java language, so they must be simulated for the Android phone using code. The basic concept behind tilesheets is complex. A tilesheet is made up of many 8x8 squares. Each square is referred to as a tile. The tilesheet itself can contain many hundreds of tiles. The game uses the tilesheet to draw the background that the user sees as they play the game. Rather than paint a different background for each level, a map is used. The map is a matrix, and each number in this 2D matrix represents an 8x8 tile from the tilesheet.

This cuts down on memory usage. Rather than save to a file the entire drawing of the background of some level, the programmer saves the matrix, or map, which is smaller but represents the same picture. The game system on which the Awesomeguy game was developed used a tilesheet/map system similar to the one described, only it was implemented on the hardware level. In order to make Awesomeguy look exactly like the original, the tilesheets from the original game were copied and imported to the Android app, and the tiling system was emulated in software.

Awesomeguy uses two map arrays for each level, and it uses four tile sheets. The tilesheets are shared by all levels of the game, and they are nearly identical.

The first map array holds a definition for the background of the level that is much the same as the one discussed above. This is a map of the visible background of the level that's being played. The second map array is identical in size to the first one. It holds information about what each picture in the other map means to the program and the character. Where the first map shows a solid wall, the second map holds a number that tells the program that the character may not pass through it. Walls in the first array can be many colors and patterns as chosen from the tilesheet, but in the second array, just one number corresponds to all wall objects. The first array is visible while the second array is never seen. The first array is referred to as the 'level' or 'tile' array, and the second array is referred to as the 'objects' array. Remember, the two arrays are always the same size.

The way the four tilesheets work is relatively simple. They are identical in size and content except for the images imbedded in the tilesheet of the rings. The rings are prizes in the game and when you get one you get points. There are four tilesheets so that the rings can be animated and made to look like they are turning. The difference in the ring images is the only difference in the four tilesheets. To make the rings look like they are moving the tilesheets are swapped during game play. This swapping happens in the JNI functions. 

===Tilemaps===

Another important component in the Awesomeguy game is the set of map arrays collectively known as tilemaps. These large 2 dimensional arrays contain the data that is used to decide what gets painted on the background screen and where it gets painted. The tilesheets are divided up into 8x8 squares. Every square gets a number, and those numbers populate the tilemaps. One of the tilemap's indexes represents the x axis, and another represents the y axis. The matrix then can cover a 2D plane with values. If the programmer wants to put a ladder in the upper left hand corner, he or she takes a 8x8 square representing a ladder from the tilesheet and places it in the tilemap at the location with the 0,0 indexes. The screen is defined this way, so that the upper-right has high x values and low y values, the lower-left has high y values and low x values, and the lower-right has both high x and y values. This reflects the numbering of pixels on a computer screen, but in this model each pixel is a complete tile from the tilesheet.

Tilesheets are not numbered with two indexes. Tilesheet 8x8 squares are numbered with a single index. For this reason it's difficult to change the size of a tilesheet once it has been established. A tilesheet containing 8x8 squares in a pattern of 3 tiles by 5 tiles would have tiles numbered 0 to 14. A tilemap element contains one of these numbers. One number typically represents 'nothing' or 'no contents', while another number might represent a solid object (like a wall) and another number might symbolize the tile that contains the image for a ladder.

For Awesomeguy there are two identical tilemaps. One holds all the information mentioned above. It holds designations for where to place tiles that show images of walls and ladders and floors. The second tilemap holds extra information that the game needs. This info includes the starting location of the main character, the starting location of each monster, further information about the location of walls and floors, the location of floating platforms, and the location of all the rings and prizes on the level. It holds the code for the checkpoint character and the level goal character and also the code for a special tile that causes instant death when it is touched. The two tilemaps are called the 'level' tilemap and the 'object' tilemap. They are exactly the same size, and an element at a certain x/y location on one map refers to the same spot on the screen as that x/y location on the other map. The two maps can be laid on top of each other.

The reason for two maps is so that one map, the 'level' map, can be responsible for drawing the image of the background, while the other map, the 'object' map, is responsible for telling the program how to treat that particular set of elements. Only some of the 'object' map elements result in an actual object being drawn on the screen. Rings, for example, are drawn on the screen until the player gets them. Similarly, not all 'level' objects are solid objects. Some, like some of the pillars, are only for outward appearances. 

===Sprites===

Aside from the tilesheets and tilemaps described above, the game uses several sprite images. For these images small 'png' files were used. There are four images of the main character and two images of the monster for each direction. That means four monster images in total, two left and two right. The multiple images are used to animate the main character and the monsters. Each of the 'png' images has an alpha channel (a transparent area) and is indexed to a 256 color palette. The size of the images is unimportant on the android phone, but for the Nintendo DS it was dictated by the hardware. For this reason the monster sprite uses only the top half of the png image, which is 16 pixels by 16 pixels. The main character is also 16 x 16, but it uses the space more evenly. 

===Software Tools===

Several pieces of software were used when making Awesomeguy. Awesomeguy was programmed on a Linux computer. The graphic images in the game were all edited on Gimp, the Gnome Image Manipulation Program. The source code for Awesomeguy was edited using the Eclipse IDE for java. The C library used for the Awesomeguy Java Native Interface (JNI) was edited using Gedit, a Gnome text editor. The tilemaps, the large arrays that define the appearance of each level, were edited first using a Windows program called 'Mappy', and then further edited using Gedit and the command line tool 'sed'. The Wine (Wine Is Not An Emulator) program loader was employed to allow Mappy to work on a Linux platform. Instructions for using Mappy to create level definitions will accompany this document. 

=Java=

The game was actually programmed somewhat successfully in java before a JNI library was added. The graphics for the game all appeared in its correct position on the screen in a version that ran on the emulator. The main problem was that the java version of the game was slow. 

===Tilesheets===

Tilesheets are not supported by java. In order to implement them in java a special class was added to the android project. The TileCutter class took the raw tilesheet and cut the image into smaller pieces that were applied to the screen one at a time as tiles.

===!TileCutter java===

The first thing we do in TileCutter is define some variables.
{{{
	private int mTilesHeight = 128;
	private int mTilesWidth = 224;
	private int mBlockHeight = 8;
	private int mBlockWidth = 8;
	private int mNumTiles = 0;
	private int mWidthInTiles = mTilesWidth/ mBlockWidth;
	private int mHeightInTiles = mTilesHeight/ mBlockHeight;
	
	private Matrix mMatrix = new Matrix();
	private Bitmap mTileMap;
	private int mScale;
	private int mTileAdjustment = 1;
}}}
The variables 'mTilesHeight' and 'mTilesWidth' are constants that describe the dimensions of the tilesheet image. There are four tilesheet images, but they're almost identical. Their dimensions have to be the same. The four sheets are 128 pixels high and 224 pixels wide. Also, a block or tile is 8 pixels high and 8 pixels wide. The variables 'mWidthInTiles' and 'mHeightInTiles' are easily computed. 

The ultimate goal is for us to be able to pass a method in the class a number that is associated with an individual tile, and for the method to return the tile that we specify. We achieve this goal by ultimately using simple calculations. We take one parameter and do some simple math, and feed the results into the 'Bitmap.createBitmap(...)' method, returning the Bitmap of the tile that we're interested in. Below are listings.

{{{
public Bitmap getTile(int i) {
	//i = i + mTileAdjustment;
	int row = i / mWidthInTiles;
	int col = i - (mWidthInTiles * row) ;
	
	if (row > this.mHeightInTiles || row < 0) row = 0;
	if (col > this.mWidthInTiles || col < 0) col = 0;
	
	int height = this.mBlockHeight;
	int width = this.mBlockWidth;

	Bitmap temp = Bitmap.createBitmap(mTileMap, col * width,row * height, width , height ,null,false);
	if (mScale != 1) {
		mMatrix.setScale(mScale, mScale);
		return Bitmap.createBitmap(temp, 0,0, width , height ,mMatrix,false);
	}
	else {
		return temp;
	}
}
}}}
Essentially we need the row and column values, and we get those by manipulating the 'mWidthInTiles' variable. Extra code is added for scaling the images. If we want to double the images size for larger screens we can do this with the 'mMatrix' object. The value of 'mScale' is set using a regular java setter method.

===Panel java===

Then we need to use the TileCutter in the 'onDraw(...)' method of the Panel.java class. We do this using two for() loops and the TileCutter object.
{{{
	    	mCanvas.drawColor(Color.BLACK);
	    	mTiles = new TileCutter(bMap);
	        baseX = scrollX/ mTiles.getBlockWidth();
	        baseY = scrollY/ mTiles.getBlockHeight();
    		
	    		for ( int i = baseX; i < baseX + 32 + 1; i ++ ) { 
	
	    			for (int j = baseY; j < baseY + 24 + 1; j ++) { 
	    				if (mGameV.getLevelCell(i, j) != 0 ) {
	    					//print visible background
	    					mTemp = mGameV.getLevelCell(i, j);
	    					mBlock = mTiles.getTile(mTemp);
	    					canvas.drawBitmap(mBlock, i * mTiles.getBlockWidth(), j* mTiles.getBlockHeight(), null);
	    				}
	    				if (mGameV.getObjectsCell(i, j) != 0) {
	    					//print special background objects
	    					mTemp = mGameV.getObjectsCell(i, j);
	    					if(this.checkPrintableObjects(mTemp)) {
	    						mBlock = mTiles.getTile(mTemp - mMapcheat);
	    						canvas.drawBitmap(mBlock, i * mTiles.getBlockWidth(), j* mTiles.getBlockHeight(), null);
	    					}
	    				}
	    				
	    			}
	    		}
    		
}}}
The indexes for these two loops are the most complicated part. We know that we are going to scroll the screen, and that the level graphics themselves are bigger than the area that is being shown on the screen. What we want to do is paint tiles where the screen is going to be, and not concern ourselves with other parts of the screen. The variables scrollX and scrollY represent the top left of the screen that is going to be displayed. They are pixel values, so we translate them to multiples of 8. This is what baseX and baseY represent, and they are the starting points for the two loops. Then we set the ending point of the loops as the size in tiles of the screen that's being shown. For the original game this was 32 tiles wide and 24 tiles high. (Note that a single tile is added to the 32 and 24 so that there was no chance that the screen would be blank at any point)

The indexes of the two loops are used by the method calls 'mGameV.getLevelCell(i,j)' and 'mGameV.getObjectsCell(i,j)'. These functions return tile numbers, which are used by the TileCutter class and various other parts of the program.

In the 'canvas.drawBitmap(...)' function the indexes from the loops (i and j) are multiplied by 8 to translate the tile position into actual pixels.

We accomplish drawing the background on the screen this way using tiles instead of, for example, a large bitmap that fills the whole screen. What we have to do then is use the built in scroll function of the View class (remember the Panel.java class extends the android View). Every View has a scrolling mechanism, and it's simple to use. We scroll the upper left hand corner of the window that the user sees to the coordinates of scrollX and scrollY.
{{{
scrollTo(scrollX, scrollY);
}}}

The process of using the TileCutter and the loops described above is time consuming, so a JNI library was used.

=JNI Setup=

JNI stands for 'Java Native Interface' and NDK stands for 'Native Development Kit'. To program JNI for the android platform you must download and configure the 'android-ndk-r4' package, which can be found on the Android developers site at the following address. See: http://developer.android.com/sdk/ndk/index.html . Download and install the package that is appropriate for your operating system. Installing this software is beyond the scope of this wiki. The documentation that accompanies the ndk software is very helpful. 

===Names===

The name of the file that's compiled into the awesomeguy JNI library is 'awesomeguy.c', and the actual compiled library is called 'libawesomeguy.so'. The Android NDK package takes care of naming the actual library for us, so we only have to concern ourselves with writing the awesomeguy.c file. To compile a Android JNI library, we create a folder in the Eclipse project called 'jni'. We place the c file in this folder. There is a non trivial step of creating the android 'Android.mk' file, which is the library's 'make' file. Then we use tools from the Android NDK package to compile the file. 

The NDK tools create the actual library for us and place the library in a specially created folder in the Eclipse project. When Eclipse creates the app file it includes the library automatically. We have to 'Refresh' the project manually every time we re-compile the library, but that's the only tricky part. To refresh the project, press the F5 button.

===Awesomeguy in c===

Both c and c++ can be used for Android JNI. Awesomeguy uses c. The c programming language is very complex, and is not explained in any depth here. Some c concepts are touched upon, though. The Awesomeguy JNI library is somewhat lengthy, but relatively simple in concept. It's important to remember that with awesomeguy.c we are building a library, not a running program, so there is no 'main()' method. Another thing to remember is that for the JNI in Awesomeguy we want a single source file (awesomeguy.c) and a single library file (libawesomeguy.so). This requirement is so that the program remains simple enough to be easily maintained. It also means that there are no separate header files for the library. If your library is complex enough, header files might be necessary.

There is no boolean data type in c. Instead you must use integers. Awesomeguy uses a pair of `#define` statements to create 'TRUE' and 'FALSE' values that correspond to integer values of '1' and '0'. For this reason when the awesomeguy library is asked by the java code to return a true or false it returns an integer which must be translated somehow for the java code. Java does use a separate boolean data type.

The awesomeguy JNI library is meant to operate within the context of the Panel.java class. JNI code will only be called from that class. This simplifies the awesomeguy.c file slightly.

===include===

There are four `#include` statements at the beginning of the awesomeguy.c file.
{{{
#include <jni.h>
#include <android/log.h>
#include <stdio.h> 
#include <stdlib.h>
}}}
The first two are specific to android JNI programming. They allow the project to interface with the java code, and allow our program to print log messages to the Dalvik Debugger. This is important for development and debugging. Once the c library is working correctly the line `#include <android/log.h>` could be removed.

The second two `#include` statements are standard c libraries that any c programmer might use in their program. You can `#include` many c libraries, and also several libraries that are provided by google for programming the Android device.

===define===

The first set of `#define` statements is used to set up logging. The lines of code here set up methods or macros that can be used to print messages to the debugger's log. These are not strictly necessary for the operation of the awesomeguy JNI library.

{{{
#define  LOG_TAG              "awesomeguy-jni"
#define  LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
#define  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
}}}

Next the constants for 'TRUE' and 'FALSE' are defined.

{{{
#define TRUE 1
#define FALSE 0 
}}}

===constants===

The next thing we do is define some constants that will be used by the program. First among these variables is the definition of various tile numbers. For example throughout the game solid objects are represented by the number 442. Each different kind of object that can be placed on the screen is represented by a different number.
{{{
static int B_START = 5;
static int B_SPACE = 0;
static int B_LADDER = 444;
static int B_BLOCK = 442;
static int B_GOAL = 446;
static int B_KEY = 445; 
static int B_PRIZE =  447;
static int B_MONSTER = 443;
static int B_MARKER = 441; 
static int B_DEATH = 439 ;
static int B_ONEUP = 438 ;
static int B_BIBPRIZE = 440 ;
static int B_PLATFORM = 437 ; 
}}}

Then there are various other constants, some of which are self explanatory.
{{{
static int TILEMAP_WIDTH = 224;
static int TILEMAP_HEIGHT = 128;
 
static int TILE_WIDTH = 8;
static int TILE_HEIGHT = 8;
 
static int GUY_WIDTH = 16;
static int GUY_HEIGHT = 16;
static int GUY_CHEAT = 3;
 
static int MONSTER_WIDTH = 16;
static int MONSTER_HEIGHT = 16;
 
static int PLATFORM_WIDTH = 40;
static int PLATFORM_HEIGHT = 8;
 
static int MAP_WIDTH = 96;
static int MAP_HEIGHT = 96;
 
static int SCREEN_WIDTH = 256;
static int SCREEN_HEIGHT = 192;
}}}

TILEMAP_WIDTH and TILEMAP_HEIGHT refer to the pixel dimensions of the tilesheet. MAP_WIDTH and MAP_HEIGHT refer to the array that represents the way the background should be drawn. This is slightly misleading, as in this documentation (up till now) TILEMAP would refer to the 96x96 object, and TILESHEET would be the appropriate term for the graphics that are cut apart and used as individual tiles. Unfortunately the awesomeguy.c file was written without regard to these conventions, so discussion of the variables may remain somewhat ambiguous.

This section is followed by more variables that are used by the library. These two variables are used by the functions that copy sprites and tiles to the screen array. They are flags and will be discussed later.
{{{
static int PAINT_SOLID = 0;
static int PAINT_TRANSPARENT = 1;
}}}

===Scope===

These variables are all declared outside any method body, so they have global scope. Up until now the variables declared have been constants, but many of the variables, like the 2D array 'screen' have contents that change over time. This is because 'screen' is rewritten every time the Panel redraws itself. This is OK for our library. The contents of 'screen' are persistent over many calls to the library, and are also changeable over many calls to the library.

===Unsigned Integers===

The thirteen arrays below are used to hold the data that makes up several Bitmap images. These images are loaded when the Panel.java file is initialized. They are not loaded and reloaded every time the Panel.java file draws an image to the screen. Arrays in c are really made of two things. Firstly the memory for the array is allocated, and secondly a pointer is created to the beginning of the array. The data type used here is `uint32_t`, which is an unsigned integer of 32 bits. This is the data type I use for all graphical information. Graphical elements, or pixels, are going to be stored in these arrays.
{{{
static uint32_t tiles_a[128][224];
static uint32_t tiles_b[128][224];
static uint32_t tiles_c[128][224];
static uint32_t tiles_d[128][224];
 
static uint32_t guy_a[16][16];
static uint32_t guy_b[16][16];
static uint32_t guy_c[16][16];
static uint32_t guy_d[16][16];
 
static uint32_t monster_a[16][16];
static uint32_t monster_b[16][16];
static uint32_t monster_c[16][16];
static uint32_t monster_d[16][16];
 
static uint32_t platform_a[8][40];
}}}

===Map Arrays===

These are the two arrays that the JNI use as maps for the background elements. Elsewhere in this documentation the maps were called 'tilemaps'. Each element is a number representing an 8x8 square. In the Java code these arrays are located in the GameValues class, and are called the 'level' and 'objects' arrays. They are duplicated in the JNI because JNI functions are responsible for drawing the screen just as the Java was. The 'map_level' array holds just visual information, and the 'map_objects' array holds info on (usually) non visible information.

{{{
static int map_level [96][96];

static int map_objects[96][96];
}}}

===Screen===

There is an array in the variable definition section of the JNI file that represents the information that will ultimately be displayed on the screen. It is intended to hold graphical information, pixels, and it is the size of the maximum that the screen is allowed to be, (192x256). This is the array that is returned to the java code by the 'drawLevel()' function. This may be the most important array in the program.
{{{
uint32_t screen [192][256];
}}}

===Alpha===

A single graphic pixel is created to hold the value that is used by the JNI library as the 'transparent' color. In ping images this would be the 'alpha' color. It is set when the library is loading the tilesheet images. It's used in the 'drawScoreWords()' and 'drawScoreNumbers()' methods.

{{{
uint32_t number_alpha = 0;
}}}

===Tile Loops===

The next two variables are used by the loop mechanism that prints tiles on the 'screen' array. Their definition is mostly unimportant to the operation of the game, but should be mentioned at this point. The two variables value refers to the number of tiles that could be printed on the screen.

{{{
static int tilesWidthMeasurement = 32;
static int tilesHeightMeasurement = 32;
}}}

===Sprite Structs===

This code defines the struct that is used to hold sprite info. Because Sprites themselves are not supported in hardware on the Android phone, The Sprite mechanism is emulated here in software.

{{{
typedef struct {
	int x, y, animate;
	int facingRight, active, visible;
	int leftBB, rightBB, topBB, bottomBB;
} Sprite;
 
}}}
The variables 'facingRight', 'active', and 'visible' are all true/false values, and are treated like bool values.

The listing above defines the sprite Struct. Then below, the first line `Sprite sprite[100]` defines an array of 100 of the previously mentioned structs. After that we have three variables that help us keep track of the various sprites that we store on the list. 

First on the list are monster sprites. They are all on the list together. The `monster_num` variable keeps track of how many monster sprites we have. Then the platforms are placed on the list, if there are any. The `platform_num` variable keeps track of how many platforms are on the list (and therefore on the level). The variable `sprite_num` keeps track of how many sprites are on the list all together.
{{{
Sprite sprite[100];
int sprite_num = 0;
int monster_num = 0;
int platform_num = -1;

Sprite guy;
}}}
There is also one sprite that we keep track of that's not on the list. This is the sprite for the main character. This sprite we call 'guy'. In the java version of the graphical display code there is one list and the guy sprite is always on the list at position '0'. Because of the slight difference between the java and the JNI, the indexes of sprite objects on the list are not the same between the two parts of the program. Special care has to be taken when referring to the sprite objects.

===Bounding Box===

Another object used by the program is the bounding box. The struct for the bounding box is next in the variable declaration section of the JNI and is listed below:

{{{
typedef struct {
	int left, right, top, bottom;
} BoundingBox;
}}}

The integers 'left', 'right', 'top', and 'bottom' are all screen positions for the boundaries of a sprite's drawable region. In Awesomeguy we use a simple box for collision detection, where as in other games a more complex shape like an outline might be used. In Awesomeguy the sprites are so small that a simple box seems to work best.

===Various Variables===

Next a group of integers is defined that are used in different sections of the library.
{{{
static int level_h, level_w, score, lives, scrollx, scrolly, animate;
}}}
The variables 'level_h' and 'level_w' are the dimensions of the map, in tiles, that the current level actually uses. As noted, the map can be 96x96 tiles, but a given level may only use a smaller portion of that map. These two variables define the _used_ map area. This saves room in the awesomeguy.xml file, where level definition information is stored, as an array of 96x96 tiles is not necessarily stored. Instead, if for example 'level_h' is 32 and 'level_w' is 64, an array of 32x64 tiles is stored.

The variables 'score' and 'lives' carry the numbers that are to be printed on the screen that are associated with those values. The 'score' and 'lives' values can also change in the JNI. These changes would be detected by the java code as the Panel redraws.

The variables 'scrollx' and 'scrolly' are values passed to the JNI by the Panel.java code. They tell the JNI how to draw the screen.

The variable 'animate' is used to animate the rings that appear on many of the levels. It is a integer value between 0 and 4.

{{{
static int endlevel = FALSE;

static int sound_ow = FALSE;
static int sound_prize = FALSE;
static int sound_boom = FALSE;

static int preferences_monsters = FALSE;
static int preferences_collision = FALSE;
}}}

The remaining global variables are all boolean. The first four are used as a notification system between the JNI and the java. The variables 'endlevel', 'sound_ow', 'sound_prize' and 'sound_boom' are used to tell the java that a collision has happened that requires the Panel.java class to end game play (in the case of 'endlevel') or play a certain sound (in the case of 'sound_ow', 'sound_prize', and 'sound_boom'). Every time the Panel is redrawn these variables are checked. If their value changes from FALSE to TRUE then the java knows it has to do something.

The variables 'preferences_monsters' and 'preferences_collision' are used as notification to the JNI from the java of the Panel class. They tell the JNI weather or not monsters should appear on the screen, and weather or not those monsters can interact with the main character. This second preference, 'preferences_collision' allows the main character to travel through the levels without fear of dying from monsters.

===Function Headers===

Functions in the awesomeguy JNI library are divided into two groups. The first group is the standard function that is internal to the library and may be called anywhere in the library. The second group is the group of functions that is meant to be called by the Panel.java class. This second group of functions is all located at the end of the file. The method signature for these functions is somewhat complex. Meanwhile the first group of functions has simple signatures. For this group function headers were included in the library.

The code of the library is so straightforward that function headers might not have been strictly necessary, but they are included because the library has no header files (the library is composed of a single source c file). Though the headers appear in the file, they will not be duplicated here.

=JNI Methods=

I will attempt to go through all the methods in the file, occasionally grouping methods together that function in exactly the same way. 

===Method Overview===

The library is basically designed to produce an array that gets printed on the screen like a Bitmap image. The library takes, when it's set up, a group of arrays that are in fact Bitmaps themselves. For most of these bitmaps the methods in the library simply copy information from one array, the source bitmap, to the other array, the output screen bitmap. This is the most common scenario, and the methods that do this work are generally called 'drawSprite(..)' methods. There is some variation in the names.

Sometimes, as in the case with tilesheets, the source bitmap is altered before it's copied. When the tilesheet is the source material, the program first cuts out one of the tiles, using a method called 'cutTile(...)'. The material from this tile is copied to a local array that's the size of just one tile (8x8). Then the local array is passed to a function that operates in a manner similar to that described above - it takes a source array and copies it to the output array. This method is called 'drawTile(...)'.

The only thing left to do is make sure everything goes where it's supposed to on the screen. The locations that all these 'draw' methods use are determined in the 'drawLevel(...)' method, where the entire 'screen' array is managed and populated.

A lot of other methods are included in the library. Some draw words and numbers on the screen, like the words 'score' and 'level'. They use tiles, so they can use the 'cutTile(...)' and the 'drawTile(...)' methods. 

Some methods determine weather a collision has taken place. This would be important for the display of the 'monster' sprites. In that case the level needs to be stopped when the main character comes into contact with a monster. Collision detection is an exception to the notion that the library operates to display images only.

There are also methods in the library that turn 1 dimensional arrays into 2 dimensional array, and at least one method that turns 2 dimensional arrays into 1 dimensional arrays. This is necessary because internally the library uses 2 dimensional arrays, while the java code that passes Bitmaps to the library uses 1 dimensional arrays. Also the method that turns the 'screen' array into a Bitmap for java expects a 1 dimensional array, while the 'screen' array itself is 2 dimensional. The methods for turning 1D to 2D are all called 'copyArraysExpand(...)' or some variation on that name. The method for turning the 'screen' array into a 1D array is called 'copyScreenCompress(...)'.

===Sound Setters===

These methods set the variables 'sound_ow', 'sound_boom', and 'sound_prize'. They're fairly simple. Their signatures are listed here.

{{{
void setSoundOw() ;
void setSoundPrize() ;
void setSoundBoom() ;
}}}

The actual listing of 'setSoundOw()' is here.
{{{
void setSoundOw() {
	sound_ow = TRUE;
}
}}}
All three methods operate the same way.

===Sound Getters===

These methods are also fairly simple. Their signatures are listed here.
{{{
int getSoundOw() ;
int getSoundPrize() ;
int getSoundBoom() ;
}}}
The listing of 'getSoundOw()' is below.
{{{
int getSoundOw() {
	int temp = sound_ow;
	sound_ow = FALSE;
	return temp;
}
}}}
It's slightly more complex than the 'setSoundOw()' method, because it not only returns the value of the 'sound_ow' variable, but it resets it to FALSE. The method is used by the java code to tell if an event has transpired in the last display of the 'screen' bitmap that would call for the 'ow' sound to be played. This would be when the main character comes in contact with a monster, for example. This method is closely related to the collision detection methods of the library.

===Loading Graphic Data===

Several steps are incorporated to load the graphics data from the java code into the JNI code. This data is used to assemble the 'screen' array, which is returned to the java code and turned into a Bitmap. 

====setTileMapData()====

This function, like 'setGuyData()' and 'setMonsterData()' takes four arrays as its parameters. These arrays are 1 dimensional. The method simply passes the four arrays off to another function that rearranges their data into 2 dimensional arrays. These 2 dimensional arrays are the permanent holding area for this graphical data. The three methods are called at the time of the Panel.java class's initialization, not during the subsequent drawing of the screen. The signature for the three methods is below.
{{{
void setTileMapData(jint a[], jint b[], jint c[], jint d[] ) ;

void setGuyData(jint a[], jint b[], jint c[], jint d[] ) ;

void setMonsterData(jint a[], jint b[], jint c[], jint d[] ) ;
}}}
The contents of the 'setTileMapData(...)' method are below.
{{{
void setTileMapData(jint a[], jint b[], jint c[], jint d[] ) {


	copyArraysExpand_tileset(a, TILEMAP_WIDTH * TILEMAP_HEIGHT, tiles_a);
	copyArraysExpand_tileset(b, TILEMAP_WIDTH * TILEMAP_HEIGHT, tiles_b);
	copyArraysExpand_tileset(c, TILEMAP_WIDTH * TILEMAP_HEIGHT, tiles_c);
	copyArraysExpand_tileset(d, TILEMAP_WIDTH * TILEMAP_HEIGHT, tiles_d);
	
}
}}}
The four arrays, 'a', 'b', 'c', and 'd', are each separate tile sheets. They are nearly identical, except for the animation of the rings that the main character collects for points. The method 'copyArraysExpand_tileset(...)' will be explained below.

====setMovingPlatformData()====