#summary Method by method explanation of the 'awesomeguy.c' file.
#sidebar TableOfContents
= Introduction =

Here we'll go through a method by method explanation of the 'awesomeguy.c' file, as well as talk a little about how we might have implemented Awesomeguy's graphics in java. First, though, we'll repeat some information from another wiki that describes Awesomeguy's graphics.

<wiki:toc max_depth="5" />

=Overview=

The format of the Awesomeguy game is that of a simple platform game, in some ways like the original “Donkey Kong” or “Super Mario Brothers”. The Nintendo DS version has two screens of 192x256 pixels each. During gameplay one of the screens was generally used as a splash screen. The game also makes use of four directional keys and two special keys -- one of which is the 'jump' key. 

The android phone that the game was developed for had no "D-pad". For the android version, two separate View objects were required during regular game play. One View was for display of the game screen, the equivalent of the main screen from the Nintendo game, and the other View was the emulated "D-pad". The "D-pad" was emulated using TouchButtons? on the touch screen and also an alternative where movement instructions were taken from the trackball. The DS version of the game uses several large int arrays for keeping track of the appearance of each level in the game. In order to port the levels to the android version, the same sort of array was used in the android code. In this way the android version can use the exact same level definition info. The android version also uses an ArrayList? to keep track of sprite data, though sprites are not hardware supported in java. One ArrayList? is used for all types of sprites. The DS version makes use of a set of four tiles that are used to paint the levels from the predefined level array on the game screen. The same tile set was used in the android version, but software was used to emulate the DS's hardware tiling system. For these reasons the android version of the game is slower to play than the homebrew DS version.

===Tilesheets===

Tilesheets are very important to the Awesomeguy game. Tilesheets do not exist natively in the Java language, so they must be simulated for the Android phone using code. The basic concept behind tilesheets is complex. A tilesheet is made up of many 8x8 squares. Each square is referred to as a tile. The tilesheet itself can contain many hundreds of tiles. The game uses the tilesheet to draw the background that the user sees as they play the game. Rather than paint a different background for each level, a map is used. The map is a matrix, and each number in this 2D matrix represents an 8x8 tile from the tilesheet.

This cuts down on memory usage. Rather than save to a file the entire drawing of the background of some level, the programmer saves the matrix, or map, which is smaller but represents the same picture. The game system on which the Awesomeguy game was developed used a tilesheet/map system similar to the one described, only it was implemented on the hardware level. In order to make Awesomeguy look exactly like the original, the tilesheets from the original game were copied and imported to the Android app, and the tiling system was emulated in software.

Awesomeguy uses two map arrays for each level, and it uses four tile sheets. The tilesheets are shared by all levels of the game, and they are nearly identical.

The first map array holds a definition for the background of the level that is much the same as the one discussed above. This is a map of the visible background of the level that's being played. The second map array is identical in size to the first one. It holds information about what each picture in the other map means to the program and the character. Where the first map shows a solid wall, the second map holds a number that tells the program that the character may not pass through it. Walls in the first array can be many colors and patterns as chosen from the tilesheet, but in the second array, just one number corresponds to all wall objects. The first array is visible while the second array is never seen. The first array is referred to as the 'level' or 'tile' array, and the second array is referred to as the 'objects' array. Remember, the two arrays are always the same size.

The way the four tilesheets work is relatively simple. They are identical in size and content except for the images imbedded in the tilesheet of the rings. The rings are prizes in the game and when you get one you get points. There are four tilesheets so that the rings can be animated and made to look like they are turning. The difference in the ring images is the only difference in the four tilesheets. To make the rings look like they are moving the tilesheets are swapped during game play. This swapping happens in the JNI functions. 

===Tilemaps===

Another important component in the Awesomeguy game is the set of map arrays collectively known as tilemaps. These large 2 dimensional arrays contain the data that is used to decide what gets painted on the background screen and where it gets painted. The tilesheets are divided up into 8x8 squares. Every square gets a number, and those numbers populate the tilemaps. One of the tilemap's indexes represents the x axis, and another represents the y axis. The matrix then can cover a 2D plane with values. If the programmer wants to put a ladder in the upper left hand corner, he or she takes a 8x8 square representing a ladder from the tilesheet and places it in the tilemap at the location with the 0,0 indexes. The screen is defined this way, so that the upper-right has high x values and low y values, the lower-left has high y values and low x values, and the lower-right has both high x and y values. This reflects the numbering of pixels on a computer screen, but in this model each pixel is a complete tile from the tilesheet.

Tilesheets are not numbered with two indexes. Tilesheet 8x8 squares are numbered with a single index. For this reason it's difficult to change the size of a tilesheet once it has been established. A tilesheet containing 8x8 squares in a pattern of 3 tiles by 5 tiles would have tiles numbered 0 to 14. A tilemap element contains one of these numbers. One number typically represents 'nothing' or 'no contents', while another number might represent a solid object (like a wall) and another number might symbolize the tile that contains the image for a ladder.

For Awesomeguy there are two identical tilemaps. One holds all the information mentioned above. It holds designations for where to place tiles that show images of walls and ladders and floors. The second tilemap holds extra information that the game needs. This info includes the starting location of the main character, the starting location of each monster, further information about the location of walls and floors, the location of floating platforms, and the location of all the rings and prizes on the level. It holds the code for the checkpoint character and the level goal character and also the code for a special tile that causes instant death when it is touched. The two tilemaps are called the 'level' tilemap and the 'object' tilemap. They are exactly the same size, and an element at a certain x/y location on one map refers to the same spot on the screen as that x/y location on the other map. The two maps can be laid on top of each other.

The reason for two maps is so that one map, the 'level' map, can be responsible for drawing the image of the background, while the other map, the 'object' map, is responsible for telling the program how to treat that particular set of elements. Only some of the 'object' map elements result in an actual object being drawn on the screen. Rings, for example, are drawn on the screen until the player gets them. Similarly, not all 'level' objects are solid objects. Some, like some of the pillars, are only for outward appearances. 

===Sprites===

Aside from the tilesheets and tilemaps described above, the game uses several sprite images. For these images small 'png' files were used. There are four images of the main character and two images of the monster for each direction. That means four monster images in total, two left and two right. The multiple images are used to animate the main character and the monsters. Each of the 'png' images has an alpha channel (a transparent area) and is indexed to a 256 color palette. The size of the images is unimportant on the android phone, but for the Nintendo DS it was dictated by the hardware. For this reason the monster sprite uses only the top half of the png image, which is 16 pixels by 16 pixels. The main character is also 16 x 16, but it uses the space more evenly. 

===Software Tools===

Several pieces of software were used when making Awesomeguy. Awesomeguy was programmed on a Linux computer. The graphic images in the game were all edited on Gimp, the Gnome Image Manipulation Program. The source code for Awesomeguy was edited using the Eclipse IDE for java. The C library used for the Awesomeguy Java Native Interface (JNI) was edited using Gedit, a Gnome text editor. The tilemaps, the large arrays that define the appearance of each level, were edited first using a Windows program called 'Mappy', and then further edited using Gedit and the command line tool 'sed'. The Wine (Wine Is Not An Emulator) program loader was employed to allow Mappy to work on a Linux platform. Instructions for using Mappy to create level definitions will accompany this document. 

=Java=

The game was actually programmed somewhat successfully in java before a JNI library was added. The graphics for the game all appeared in its correct position on the screen in a version that ran on the emulator. The main problem was that the java version of the game was slow. The other problem was that the images for the game were resized by the android operating system for the larger screen found on devices like the nexus one.

===Tilesheets===

Tilesheets are not supported by java. In order to implement them in java a special class was added to the android project. The TileCutter class took the raw tilesheet and cut the image into smaller pieces that were applied to the screen one at a time as tiles.

===!TileCutter java===

The first thing we do in TileCutter is define some variables.
{{{
	private int mTilesHeight = 128;
	private int mTilesWidth = 224;
	private int mBlockHeight = 8;
	private int mBlockWidth = 8;
	private int mNumTiles = 0;
	private int mWidthInTiles = mTilesWidth/ mBlockWidth;
	private int mHeightInTiles = mTilesHeight/ mBlockHeight;
	
	private Matrix mMatrix = new Matrix();
	private Bitmap mTileMap;
	private int mScale;
	private int mTileAdjustment = 1;
}}}
The variables 'mTilesHeight' and 'mTilesWidth' are constants that describe the dimensions of the tilesheet image. There are four tilesheet images, but they're almost identical. Their dimensions have to be the same. The four sheets are 128 pixels high and 224 pixels wide. Also, a block or tile is 8 pixels high and 8 pixels wide. The variables 'mWidthInTiles' and 'mHeightInTiles' are easily computed. 

The ultimate goal is for us to be able to pass a method in the class a number that is associated with an individual tile, and for the method to return the tile that we specify. We achieve this goal by ultimately using simple calculations. We take one parameter and do some simple math, and feed the results into the 'Bitmap.createBitmap(...)' method, returning the Bitmap of the tile that we're interested in. Below are listings.

{{{
public Bitmap getTile(int i) {
	//i = i + mTileAdjustment;
	int row = i / mWidthInTiles;
	int col = i - (mWidthInTiles * row) ;
	
	if (row > this.mHeightInTiles || row < 0) row = 0;
	if (col > this.mWidthInTiles || col < 0) col = 0;
	
	int height = this.mBlockHeight;
	int width = this.mBlockWidth;

	Bitmap temp = Bitmap.createBitmap(mTileMap, col * width,row * height, width , height ,null,false);
	if (mScale != 1) {
		mMatrix.setScale(mScale, mScale);
		return Bitmap.createBitmap(temp, 0,0, width , height ,mMatrix,false);
	}
	else {
		return temp;
	}
}
}}}
Essentially we need the row and column values, and we get those by manipulating the 'mWidthInTiles' variable. Extra code is added for scaling the images. If we want to double the images size for larger screens we can do this with the 'mMatrix' object. The value of 'mScale' is set using a regular java setter method.

===Panel java===

Then we need to use the TileCutter in the 'onDraw(...)' method of the Panel.java class. We do this using two for() loops and the TileCutter object.
{{{
	    	mCanvas.drawColor(Color.BLACK);
	    	mTiles = new TileCutter(bMap);
	        baseX = scrollX/ mTiles.getBlockWidth();
	        baseY = scrollY/ mTiles.getBlockHeight();
    		
	    		for ( int i = baseX; i < baseX + 32 + 1; i ++ ) { //24
	
	    			for (int j = baseY; j < baseY + 24 + 1; j ++) { //32
	    				if (mGameV.getLevelCell(i, j) != 0 ) {
	    					//print visible background
	    					mTemp = mGameV.getLevelCell(i, j);
	    					mBlock = mTiles.getTile(mTemp);
	    					canvas.drawBitmap(mBlock, i * mTiles.getBlockWidth(), j* mTiles.getBlockHeight(), null);
	    				}
	    				if (mGameV.getObjectsCell(i, j) != 0) {
	    					//print special background objects
	    					mTemp = mGameV.getObjectsCell(i, j);
	    					if(this.checkPrintableObjects(mTemp)) {
	    						mBlock = mTiles.getTile(mTemp - mMapcheat);
	    						canvas.drawBitmap(mBlock, i * mTiles.getBlockWidth(), j* mTiles.getBlockHeight(), null);
	    					}
	    				}
	    				
	    			}
	    		}
    		
}}}
The indexes for these two loops are the most complicated part. We know that we are going to scroll the screen, and that the level graphics themselves are bigger than the area that is being shown on the screen. What we want to do is paint tiles where the screen is going to be, and not concerning ourselves with other parts of the screen. The variables scrollX and scrollY represent the top left of the screen that is going to be displayed. They are pixel values, so we translate them to multiples of 8. This is what baseX and baseY represent, and they are the starting points for the two loops. Then we set the ending point of the loops as the size in tiles of the screen that's being shown. For the original game this was 32 tiles wide and 24 tiles high.

We accomplish drawing the background on the screen this way using tiles instead of, for example, a large bitmap that fills the whole screen. What we have to do then is use the built in scroll function of the View class (remember the Panel.java class extends the android View). Every View has a scrolling mechanism, and it's simple to use.
{{{
scrollTo(scrollX, scrollY);
}}}